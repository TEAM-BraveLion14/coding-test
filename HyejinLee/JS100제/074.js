// # ë¬¸ì œ74 : ìµœì¥ ê²½ë¡œ ì°¾ê¸°

// ë‹¤ìŒê³¼ ê°™ì´ ë…¸ë“œì˜ ì—°ê²° ê´€ê³„ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. 
// ì…ë ¥ìœ¼ë¡œëŠ” ê²½ë¡œë¥¼ êµ¬í•  ë‘ ì •ì ì˜ ë²ˆí˜¸ê°€ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ì£¼ì–´ì§‘ë‹ˆë‹¤. 
// ìš°ë¦¬ëŠ” **ì´ ë‘ ì •ì ìœ¼ë¡œ ê°€ê¸° ìœ„í•œ ìµœëŒ€ ê±°ë¦¬**ë¥¼ êµ¬í•˜ê³ ì í•©ë‹ˆë‹¤. 

// ìµœëŒ€ ê±°ë¦¬ë€, ì •ì ì˜ ì¤‘ë³µ ì—†ì´ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ê¹Œì§€ ê²½ìœ í•  ìˆ˜ ìˆëŠ” ê°€ì¥ ë§ì€ ê°„ì„ ì˜ ìˆ˜ë¥¼ ëœ»í•©ë‹ˆë‹¤.

	
ë°ì´í„°
graph = {1: [2, 3, 4],
		2: [1, 3, 4, 5, 6],
		3: [1, 2, 7],
		4: [1, 2, 5, 6],
		5: [2, 4, 6, 7],
		6: [2, 4, 5, 7],
		7: [3, 5, 6]}


ì…ë ¥
1 7

ì¶œë ¥
6

----------------------------------------------------------
[ë‹¤ì‹œ í’€ì–´ë³´ê¸° ğŸ“›ğŸ“›ğŸ“›]

// ë‚´ ì½”ë“œ
graph = {1: [2, 3, 4],
	2: [1, 3, 4, 5, 6],
	3: [1, 2, 7],
	4: [1, 2, 5, 6],
	5: [2, 4, 6, 7],
	6: [2, 4, 5, 7],
	7: [3, 5, 6]}

function longest(graph, first, last) {
  const visited = [];
  const stack = [first];
  let count = 0;

  while (stack.length > 0) {
    for (let i = 0; i < stack.length; i++) {
      count++;
      let temp = stack.pop();
      if (temp === last) {
        return count;
      }
      const sub = graph[temp].filter((x) => !visited.includes(x));
      for (let s of sub) {
        stack.push(s);
      }
    }
  }
  return count;
}

console.log(longest(graph, 1, 7));	// 4

----------------------------------------------------------
/**
<ì£¼ì˜>	[â“â“â“]
ì–´ë””ë¥¼ ê±°ì¹˜ëŠëƒì— ë”°ë¼ ìµœì¥ê±°ë¦¬ê°€ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.
ex)
1->7ë¡œ ê°€ëŠ” ê²½ë¡œì˜ ê²½ìš°
1->2->5->6->7
1->3->7
ì´ëŸ° ì‹ìœ¼ë¡œ ê±°ë¦¬ ì°¨ì´ê°€ ë‚œë‹¤.
ë˜í•œ, ìµœì¥ ê±°ë¦¬ëŠ” êµ¬í•˜ëŠ” ê²Œ ë¬´ì¡°ê±´ 1ë¶€í„° ì‹œì‘ì´ë€ ë³´ì¥ë„ ì—†ë‹¤.
ë”°ë¼ì„œ ëª¨ë“  ì§€ì ë§ˆë‹¤ dfsë¥¼ í•´ë³´ë©° ìµœì¥ ê²½ë¡œë¥¼ ë”°ì ¸ì•¼ í•œë‹¤.


<í•œê³„ì > [ğŸ“›ğŸ“›ğŸ“›]
ê°œë…ì´ í™•ì‹¤íˆ ì•ˆì¡íŒ ìƒíƒœì—ì„œ í•˜ë ¤ë‹ˆê¹Œ ì•ì—ì„œ ë³¸ ë‹µì•ˆ ì½”ë“œë¡œë§Œ ëŒë ¤ë§‰ê¸° í•˜ê³  ìˆë‹¤. 
ê·¸ê²ƒ ë§ˆì €ë„ ì´ ë¬¸ì œì—ì„œëŠ” ì •ë‹µì´ í‹€ë¦° ìƒí™©
ì´í›„ì— ì²œì²œíˆ ëœ¯ì–´ë³´ì..
*/
----------------------------------------------------------

{/* <íê¸°>
graph = {1: [2, 3, 4],
	2: [1, 3, 4, 5, 6],
	3: [1, 2, 7],
	4: [1, 2, 5, 6],
	5: [2, 4, 6, 7],
	6: [2, 4, 5, 7],
	7: [3, 5, 6]}

function longest(graph, now, last){
	let visited = [];
	let now;
	// í˜„ì¬ ë…¸ë“œê°€ ë§ˆì§€ë§‰ ì§€ì ì— ë„ë‹¬í•˜ëŠ” ìˆœê°„ ê¸¸ì´ ë°˜í™˜
	if(now === last){
		return visited.length;
	}
	// í˜„ì¬ ë…¸ë“œê°€ visitedì— ì†í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ visitedì— ì¶”ê°€
	if(!visited.includes(now)){
		visited.push(now);
	}else{	// ë§Œì•½ ì†í•œ ìƒíƒœë¼ë©´ 

	}
} */}

----------------------------------------------------------

// ë‹µì•ˆ
const graph = {1: [2, 3, 4],
	2: [1, 3, 4, 5, 6],
	3: [1, 2, 7],
	4: [1, 2, 5, 6],
	5: [2, 4, 6, 7],
	6: [2, 4, 5, 7],
	7: [3, 5, 6]};

const user_input = prompt('ì…ë ¥í•´ì£¼ì„¸ìš”').split(' ');
const start = parseInt(user_input[0], 10);
const end = parseInt(user_input[1], 10);

let queue = [start];
let visited = [];

function sol(n, visited){
let node = n[n.length-1];
let length = 0;

if (node == end) {
return visited.length;
}

if (visited.includes(node)) {
return visited.length;
} else {
visited.push(node);
}
let max = [];

for (let next_node in graph[node]) {
n.push(graph[node][next_node]);

max.push(length, sol(n, visited));
length = Math.max.apply(null, max);

queue.pop();
}
return length;
}

console.log(sol(queue, visited));